[Ideas for Yage]

Have a scene.dirty flag, and nothing has its absolute matrix calculated unless scene is dirty.
I could traverse the tree and update every absolute matrix once before rendering.
But what about an improved, asynchronous update loop?

Add a max lights setting per material

Add a setting for min or max mipmap level per texture at the material level

Separate Texture into Texture and TextureSet?

Add boolean set operations to the Resource manager, to load all resources from a new level and free only those that aren't part of that set.

Create a TreeNode class in the Core library, scenes, nodes and gui elements inherit from it.

Separate out image functionality from Texture into a separate image class.

class Layer
{
	bool passthrough;			// pass events that occur on this layer to those behind it.

	setOnClick(function);		// mousebutton, mouseposition
	setOnDblClick(function);
	setOnKeyDown(function);		// send the keyboard key and modifier
	setOnKeyUp(function);
	setOnMouseMove(function);	// new location, distance
	onMouseDrag(function);		// button being draged, also above params
	
	getNodeAtPosition(x, y);
	setMaterial();
	
	// Set style
	// Parses sring and stores in a style struct.
	// Three units, px, pt, and %.
	// 1px is literally 1 pixel
	// 1% is 1% the width of the parent Element
	// 1pt is 1% the width of the window.
	// Position can be absolute or inline.
	setStyle("border: 12px garient blue; font-size: 12pt; display: inline");
	
	setText("Hello <b>World</b>");
}

Put update in its own thread and synchronize where necessary

Create a copy of all nodes in its tree for camrea->toTexture(), so update can be called multiple times per render.
Or just have each node have copies of its relative and absolute matrices.  Even better--just set a lock flag for each Node and the camera renderer waits until the Node is unlocked.

Break apart Device.init() into different subsystems, and reduce dependance on dll's to only when they're actually used.

A sensor node that checks for certain events (brightness, velocity, distance, etc.) and calls callback functions when
certain events occur.

Use axis sorting to tell what lights affect what nodes (instead of n*m distance check).  But most lights have large radius?

Use dx cross dy to calculate normals for parametric graphnodes.

