<html><head>
	<META http-equiv="content-type" content="text/html; charset=utf-8">
	<title>yage.core.quatrn</title>
	</head><body>
	<h1>yage.core.quatrn</h1>
	<!-- Generated by Ddoc from yage\core\quatrn.d -->
<b>Authors:</b><br>
Eric Poggel
<br><br>
<b>License:</b><br>
<a href="lgpl.txt">LGPL</a>
 
<br><br>

<dl><dt><big>struct <u>Quatrn</u>;
</big></dt>
<dd>A quaternion class.
 Quaternion are 4 dimensional constructs often used in rotation to avoid
 gimbal lock. This is named <u>Quatrn</u> instead of Quaternion for easier typing.
 This is defined as a struct instead of a class so it can be created and
 destroyed without dynamic memory allocation.
<br><br>
<b>See Also:</b><br>
<a href="http://en.wikipedia.org/wiki/Quaternion">Wikipedia: Quaternion</a><br>
 <a href="http://www.gamedev.net/reference/articles/article1691.asp">The Matrix and Quaternion Faq</a>
<br><br>

<dl><dt><big>static Quatrn  <u>opCall</u>();
</big></dt>
<dd>Create a unit Quaternion.
<br><br>

</dd>
<dt><big>static Quatrn  <u>opCall</u>(float <i>x</i>, float <i>y</i>, float <i>z</i>, float <i>w</i>);
</big></dt>
<dd>Create a Quaternion from four values.
<br><br>

</dd>
<dt><big>static Quatrn  <u>opCall</u>(float[] <i>s</i>);
</big></dt>
<dd>Create a Quaternion from an array of floats.
<br><br>

</dd>
<dt><big>static Quatrn  <u>opCall</u>(Vec3f <i>axis</i>);
</big></dt>
<dd>Create a Quaternion from a rotation <i>axis</i> Vec3f.
<br><br>

</dd>
<dt><big>static Quatrn  <u>opCall</u>(Matrix <i>m</i>);
</big></dt>
<dd>Create a Quaternion from a rotation Matrix.
<br><br>

</dd>
<dt><big>Quatrn  <u>opMul</u>(Quatrn <i>b</i>);
</big></dt>
<dd>Multiply this quaternion by another and return the result.
  The result is the sum of both quaternion rotations.
  Note that quaternion multiplication is not cumulative.
<br><br>

</dd>
<dt><big>bool <u>almostEqual</u>(Quatrn <i>s</i>, float <i>fudge</i> = 0.0001F);
</big></dt>
<dd>Is this Quatrn equal to Quatrn <i>s</i>, discarding relative error <i>fudge</i>.
<br><br>

</dd>
<dt><big>Quatrn  <u>conjugate</u>();
</big></dt>
<dd>Return the <u>conjugate</u> the Quaternion
<br><br>

</dd>
<dt><big>Quatrn  <u>inverse</u>();
</big></dt>
<dd>Return the <u>inverse</u> of the Quaternion.
 This is the equivalent of the Quaternion's rotation in reverse. 
<br><br>

</dd>
<dt><big>float <u>length</u>();
</big></dt>
<dd>Get the magnitude of the Quaternion.
<br><br>

</dd>
<dt><big>Quatrn  <u>normalize</u>();
</big></dt>
<dd>Return a normalized version of the Quaternion.
<br><br>

</dd>
<dt><big>void* <u>ptr</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big>Quatrn  <u>rotate</u>(Quatrn <i>q</i>);
</big></dt>
<dd>Return a new Quaternion that is the sum of the current rotation and the
 new rotation of the parameter. 
<br><br>

</dd>
<dt><big>Quatrn  <u>rotateAbsolute</u>(Quatrn <i>q</i>);
</big></dt>
<dd>Return a new Quaternion that is the sum of the current rotation and the
 new rotation of the parameter, rotating in absolute worldspace coordinates. 
<br><br>

</dd>
<dt><big>Quatrn  <u>rotateEuler</u>(Vec3f <i>euler</i>);
</big></dt>
<dd>Return a new Quaternion that is the sum of the current rotation and the
 new rotation of the Vec3f of <i>euler</i> angles, rotating first by x, then y, then z. 
<br><br>

</dd>
<dt><big>Quatrn  <u>rotateEulerAbsolute</u>(Vec3f <i>euler</i>);
</big></dt>
<dd>Return a new Quaternion that is the sum of the current rotation and the
 new rotation of the Vec3f of <i>euler</i> angles, rotating first by x, then y,
 then z, rotating around the absolute worldspace axis 
<br><br>

</dd>
<dt><big>void <u>set</u>(float <i>x</i>, float <i>y</i>, float <i>z</i>, float <i>w</i>);
</big></dt>
<dd>Set the Quaternion using four scalar values.
<br><br>

</dd>
<dt><big>void <u>set</u>(float[] <i>s</i>);
</big></dt>
<dd>Set to an array of floats (x,y,z,w)
<br><br>

</dd>
<dt><big>void <u>set</u>(Vec3f <i>axis</i>);
</big></dt>
<dd>Set the Quaternion using a rotation <i>axis</i> Vec3f.
<br><br>

</dd>
<dt><big>void <u>set</u>(Matrix <i>r</i>);
</big></dt>
<dd>Set the Quaternion to the rotation part of a Matrix.
<br><br>

</dd>
<dt><big>void <u>setEuler</u>(Vec3f <i>euler</i>);
</big></dt>
<dd>Set the rotation using a Vec3f of Euler angles.
<br><br>

</dd>
<dt><big>Quatrn  <u>slerp</u>(Quatrn <i>q</i>, float <i>interp</i>);
</big></dt>
<dd>Return a rotation that is interpolated between this Quaternion and
 the Quatrn <i>q</i>. 
<br><br>

</dd>
<dt><big>Vec3f  <u>toAxis</u>();
</big></dt>
<dd>Create a Vec3f rotation axis from this Quaternion
<br><br>

</dd>
<dt><big>Matrix  <u>toMatrix</u>();
</big></dt>
<dd>Create a rotation Matrix from this quaternion.
<br><br>

</dd>
<dt><big>char[] <u>toString</u>();
</big></dt>
<dd>Return a string representation of this quaternion for human reading.
<br><br>

</dd>
</dl>
</dd>
</dl>

	<hr><small>Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. (c) 2005-2007 Eric Poggel
</small>
	</body></html>
