<html><head>
	<META http-equiv="content-type" content="text/html; charset=utf-8">
	<title>yage.node.light</title>
	</head><body>
	<h1>yage.node.light</h1>
	<!-- Generated by Ddoc from yage\node\light.d -->
<b>Authors:</b><br>
Eric Poggel
<br><br>
<b>License:</b><br>
<a href="lgpl.txt">LGPL</a>
 
<br><br>

<dl><dt><big>class <u>LightNode</u>: yage.node.node.Node;
</big></dt>
<dd>LightNodes are Nodes that emit light.
 Opengl hardware lights are used by default, but shaders can be used to go
 beyond their capabilities.  Each material has an optional max-lights property
 and this is used to only enable the lights that most affect the polygons
 when rendering that instance of the material.
<br><br>
All color values are floating point in the range from 0 to 1 and in the order
 of red, green, blue and alpha.  For example,
 (1, .5, 0, 0) is orange, since it is 100% red and 50% green.
<br><br>

<dl><dt><big>this(BaseNode <i>parent</i>);
</big></dt>
<dd>Construct this Node as the child of <i>parent</i>.
<br><br>

</dd>
<dt><big>this(BaseNode <i>parent</i>, LightNode <i>original</i>);
</big></dt>
<dd>Construct this Node as a copy of another Node and recursively copy all children.
<br><br>
<b>Params:</b><br>
<table><tr><td>BaseNode <i>parent</i></td>
<td>This Node will be a child of <i>parent</i>.</td></tr>
<tr><td>LightNode <i>original</i></td>
<td>This Node will be an exact copy of <i>original</i>.</td></tr>
</table><br>

</dd>
<dt><big>Node <u>setParent</u>(BaseNode <i>parent</i>);
</big></dt>
<dd>Overridden from Node's <u>setParent</u>() to ensure that the Scene's list of lights
 is updated if the Light is moved from one scene to another. 
<br><br>

</dd>
<dt><big>void <u>remove</u>();
</big></dt>
<dd>Overridden to <u>remove</u> the light from the Scene's arary of lights
<br><br>

</dd>
<dt><big>Vec!(float,4)  <u>getAmbient</u>();
</big></dt>
<dd>Get the ambient color of the light.
<br><br>

</dd>
<dt><big>void <u>setAmbient</u>(float <i>r</i>, float <i>g</i>, float <i>b</i>);
</big></dt>
<dd>Set the ambient color of the light.
<br><br>

</dd>
<dt><big>void <u>setAmbient</u>(Vec!(float,4) <i>ambient</i>);
</big></dt>
<dd>Set the <i>ambient</i> color of the light.
<br><br>

</dd>
<dt><big>Vec!(float,4)  <u>getDiffuse</u>();
</big></dt>
<dd>Get the diffuse color of the light.
<br><br>

</dd>
<dt><big>void <u>setDiffuse</u>(float <i>r</i>, float <i>g</i>, float <i>b</i>);
</big></dt>
<dd>Set the diffuse color of the light.
<br><br>

</dd>
<dt><big>void <u>setDiffuse</u>(Vec!(float,4) <i>diffuse</i>);
</big></dt>
<dd>Set the <i>diffuse</i> color of the light.
<br><br>

</dd>
<dt><big>Vec!(float,4)  <u>getSpecular</u>();
</big></dt>
<dd>Get the specular color of the light.
<br><br>

</dd>
<dt><big>void <u>setSpecular</u>(float <i>r</i>, float <i>g</i>, float <i>b</i>);
</big></dt>
<dd>Set the specular color of the light.
<br><br>

</dd>
<dt><big>void <u>setSpecular</u>(Vec!(float,4) <i>specular</i>);
</big></dt>
<dd>Set the <i>specular</i> color of the light.
<br><br>

</dd>
<dt><big>float <u>getSpotAngle</u>();
</big></dt>
<dd>Get the spotlight angle of the light, in radians.
<br><br>

</dd>
<dt><big>void <u>setSpotAngle</u>(float <i>radians</i>);
</big></dt>
<dd>Set the spotlight angle of the light, in <i>radians</i>.  If the light type is a
 spotlight, this is the angle of the light cone. 
<br><br>

</dd>
<dt><big>float <u>getSpotExponent</u>();
</big></dt>
<dd>Get the spotlight exponent of the light.
<br><br>

</dd>
<dt><big>void <u>setSpotExponent</u>(float <i>exponent</i>);
</big></dt>
<dd>Set the spotlight <i>exponent</i> of the light.  If the light type is a
 spotlight, this is how focussed the light is.  Higher exponents are
 more focussed.
<br><br>

</dd>
<dt><big>ubyte <u>getLightType</u>();
</big></dt>
<dd>Get the type of the light.
  0 for directional, 1 for point, or 2 for spot. 
<br><br>

</dd>
<dt><big>void <u>setLightType</u>(int <i>type</i>);
</big></dt>
<dd>Set the <i>type</i> of the light.
  0 for directional, 1 for point, or 2 for spot. 
<br><br>

</dd>
<dt><big>float <u>getLightRadius</u>();
</big></dt>
<dd>Get the radius of the light.  This is not the same as the Node's radius, see below.
<br><br>

</dd>
<dt><big>void <u>setLightRadius</u>(float <i>radius</i>);
</big></dt>
<dd>Set the <i>radius</i> of the light.  Default value is 256.
  Quadratic attenuation is used, so the brightness of an object is Radius^2/distance^2,
  Using this formula, a brightness of 1.0 or higher is 100% bright.
<br><br>

</dd>
<dt><big>float <u>getQuadraticAttenuation</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big>Vec3f  <u>getBrightness</u>(Vec3f <i>point</i>, float <i>margin</i> = 0F);
</big></dt>
<dd>Return the RGB brightness of the given <i>point</i>, as influenced only by this light, using
 OpenGl's fixed-function, traditional lighting calculations.  The diffuse and ambient values
 of the light are taken into effect, while the specular is not, since it depends on the
 viewing angle of the camera.
 Also note that this does not take into account shadows or anything of that nature.
<br><br>
<b>Params:</b><br>
<table><tr><td>Vec3f <i>point</i></td>
<td>3D coordinates of the <i>point</i> to be evaluated.</td></tr>
<tr><td>float <i>margin</i></td>
<td>For spotlights, setting a <i>margin</i> cause this function to return brightest <i>point</i> inside
 of that radius.  This is used internally for nodes that have a spotlight shine on
 one corner of them but not at all at their center.</td></tr>
</table><br>
<b>Returns:</b><br>
RGB color value in a Vec3f of floats from 0 to 1.
<br><br>

</dd>
</dl>
</dd>
</dl>

	<hr><small>Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. (c) 2005-2007 Eric Poggel
</small>
	</body></html>
