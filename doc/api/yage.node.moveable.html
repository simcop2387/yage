<html><head>
	<META http-equiv="content-type" content="text/html; charset=utf-8">
	<title>yage.node.moveable</title>
	</head><body>
	<h1>yage.node.moveable</h1>
	<!-- Generated by Ddoc from yage\node\moveable.d -->
<b>Authors:</b><br>
Eric Poggel
<br><br>
<b>License:</b><br>
<a href="lgpl.txt">LGPL</a>
 
<br><br>

<dl><dt><big>template <u>MoveableNode</u>()</big></dt>
<dd>Nodes have numerous methods for changing position and velocity.
 They are separated into this templated mixin to reduce the length of base.d and keep things better organized.
<br><br>
<b>See Also:</b><br>
yage.node.Node
 yage.node.BaseNode 
<br><br>

<dl><dt><big>Matrix* <u>getTransformPtr</u>();
</big></dt>
<dd>Return a pointer to the transformation Matrix of this Node.  This is faster than returning a copy.
<br><br>

</dd>
<dt><big>Matrix* <u>getAbsoluteTransformPtr</u>();
</big></dt>
<dd>Return a pointer to the transformation Matrix of this Node.  This is faster than returning a copy.
<br><br>

</dd>
<dt><big>Matrix <u>getTransform</u>(bool <i>cached</i> = false);
</big></dt>
<dd>Return the relative transformation Matrix of this Node.  This Matrix stores the position
 and rotation relative to its parent.
<br><br>
<b>Params:</b><br>
<table><tr><td>bool <i>cached</i></td>
<td>Get the transformation Matrix <i>cached</i> after the last complete scenegraph update,
 instead of the current version.  This can be used to avoid working with a half-updated scenegraph.</td></tr>
</table><br>

</dd>
<dt><big>Matrix <u>getAbsoluteTransform</u>(bool <i>cached</i> = false);
</big></dt>
<dd>Get the absolute transformation Matrix of this Node, calculating it if necessary.
<br><br>
<b>Params:</b><br>
<table><tr><td>bool <i>cached</i></td>
<td>Get the absolute transformation Matrix <i>cached</i> after the last complete scenegraph update,
 instead of the current version.  This can be used to avoid working with a half-updated scenegraph.</td></tr>
</table><br>

</dd>
<dt><big>Vec3f <u>getPosition</u>();
</big></dt>
<dd>Get the position of this Node relative to its parent's location.
 Note that changing the values of the return vector will not affect the Node's position. 
<br><br>

</dd>
<dt><big>Vec3f <u>getAbsolutePosition</u>();
</big></dt>
<dd>Get the absolute position of this Node, calculating it if necessary.
 Note that changing the values of the return vector will not affect the Node's position. 
<br><br>

</dd>
<dt><big>Vec3f <u>getRotation</u>();
</big></dt>
<dd>Get the rotation of this Node relative to its parent's rotation.
 Note that changing the values of the return vector will not affect the Node's rotation. 
<br><br>

</dd>
<dt><big>Vec3f <u>getAbsoluteRotation</u>();
</big></dt>
<dd>Get the absolute rotation of this Node, calculating it if necessary.
 Note that changing the values of the return vector will not affect the Node's rotation. 
<br><br>

</dd>
<dt><big>void <u>setTransform</u>(Matrix <i>transform</i>);
</big></dt>
<dd>Set this Node's relative transformation Matrix.
<br><br>

</dd>
<dt><big>void <u>setPosition</u>(float <i>x</i>, float <i>y</i>, float <i>z</i>);
<br>void <u>setPosition</u>(Vec3f <i>position</i>);
</big></dt>
<dd>Set the position of this node relative to its parent's position and rotation.
<br><br>

</dd>
<dt><big>void <u>setRotation</u>(float <i>x</i>, float <i>y</i>, float <i>z</i>);
<br>void <u>setRotation</u>(Vec3f <i>axis</i>);
</big></dt>
<dd>Set the rotation of this Node relative to its parent's rotation, using an axis angle.
<br><br>

</dd>
<dt><big>void <u>transformation</u>(Matrix <i>t</i>);
</big></dt>
<dd>Move and rotate by the <u>transformation</u> Matrix.
 In other words, apply <i>t</i> as a <u>transformation</u> Matrix. 
<br><br>

</dd>
<dt><big>void <u>move</u>(float <i>x</i>, float <i>y</i>, float <i>z</i>);
<br>void <u>move</u>(Vec3f <i>distance</i>);
</big></dt>
<dd>Move this Node relative to its parent.
<br><br>

</dd>
<dt><big>void <u>moveRelative</u>(float <i>x</i>, float <i>y</i>, float <i>z</i>);
<br>void <u>moveRelative</u>(Vec3f <i>direction</i>);
</big></dt>
<dd>Move this Node relative to the direction it's pointing (relative to its rotation).
<br><br>

</dd>
<dt><big>void <u>rotate</u>(float <i>x</i>, float <i>y</i>, float <i>z</i>);
<br>void <u>rotate</u>(Vec3f <i>axis</i>);
</big></dt>
<dd>Rotate this Node relative to its current rotation axis, using an axis angle
<br><br>

</dd>
<dt><big>void <u>rotateAbsolute</u>(float <i>x</i>, float <i>y</i>, float <i>z</i>);
<br>void <u>rotateAbsolute</u>(Vec3f <i>axis</i>);
</big></dt>
<dd>Rotate this Node around the absolute worldspace axis, using an axis angle.
<br><br>

</dd>
<dt><big>Vec3f <u>getVelocity</u>();
</big></dt>
<dd>Get the velocity of this Node relative to its parent.
<br><br>

</dd>
<dt><big>Vec3f <u>getAbsoluteVelocity</u>();
</big></dt>
<dd>Get the absolute velocity of this Node. TODO: this can be incorrect.
<br><br>

</dd>
<dt><big>void <u>setVelocity</u>(float <i>x</i>, float <i>y</i>, float <i>z</i>);
<br>void <u>setVelocity</u>(Vec3f <i>velocity</i>);
</big></dt>
<dd>Set the velocity of this Node relative to its parent's linear and angular velocity.
<br><br>

</dd>
<dt><big>Vec3f <u>getAngularVelocity</u>();
</big></dt>
<dd>Return the angular velocity axis; the Node rotates around this axis and
 the length of this is the rotations per second in radians. 
<br><br>

</dd>
<dt><big>void <u>setAngularVelocity</u>(float <i>x</i>, float <i>y</i>, float <i>z</i>);
<br>void <u>setAngularVelocity</u>(Vec3f <i>axis</i>);
</big></dt>
<dd>Set the angular velocity axis relative to this Node's current rotation.
<br><br>

</dd>
<dt><big>void <u>accelerate</u>(float <i>x</i>, float <i>y</i>, float <i>z</i>);
<br>void <u>accelerate</u>(Vec3f <i>v</i>);
</big></dt>
<dd>Accelerate the Node in the direction specified
<br><br>

</dd>
<dt><big>void <u>accelerateRelative</u>(float <i>x</i>, float <i>y</i>, float <i>z</i>);
<br>void <u>accelerateRelative</u>(Vec3f <i>v</i>);
</big></dt>
<dd>Accelerate relative to the way this Node is rotated (pointed).
<br><br>

</dd>
<dt><big>void <u>angularAccelerate</u>(float <i>x</i>, float <i>y</i>, float <i>z</i>);
<br>void <u>angularAccelerate</u>(Vec3f <i>axis</i>);
</big></dt>
<dd>Accelerate the angular velocity of the Node by this axis.
<br><br>

</dd>
<dt><big>void <u>angularAccelerateAbsolute</u>(float <i>x</i>, float <i>y</i>, float <i>z</i>);
<br>void <u>angularAccelerateAbsolute</u>(Vec3f <i>axis</i>);
</big></dt>
<dd>Accelerate the rotation of this Node, interpreting the acceleration axis
 in terms of absolute worldspace coordinates. 
<br><br>

</dd>
</dl>
</dd>
</dl>

	<hr><small>Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. (c) 2005-2007 Eric Poggel
</small>
	</body></html>
