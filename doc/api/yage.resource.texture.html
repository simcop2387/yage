<html><head>
	<META http-equiv="content-type" content="text/html; charset=utf-8">
	<title>yage.resource.texture</title>
	</head><body>
	<h1>yage.resource.texture</h1>
	<!-- Generated by Ddoc from yage\resource\texture.d -->
<b>Authors:</b><br>
Eric Poggel
<br><br>
<b>License:</b><br>
<a href="lgpl.txt">LGPL</a>
 
<br><br>

<dl><dt><big>struct <u>Texture</u>;
</big></dt>
<dd>An instance of a <u>Texture</u>.
 This allows many options to be set per instance of a <u>Texture</u> instead of
 creating multiple copies of the <u>Texture</u> (and consuming valuable memory)
 just to change filtering, clamping, or relative scale. 
<br><br>

<dl><dt><big>int <u>blend</u>;
</big></dt>
<dd>Set how this texture is blended with others in the same layer.
<br><br>
<b>See Also:</b><br>
the TEXTURE_FILTER_* constants in yage.system.constant
<br><br>

</dd>
<dt><big>bool <u>clamp</u>;
</big></dt>
<dd>Property enable or disable clamping of the textures of this layer.
<br><br>
<b>See Also:</b><br>
<a href="http://en.wikipedia.org/wiki/Texel_%28graphics%29">The Wikipedia entry for texel</a>
<br><br>

</dd>
<dt><big>bool <u>reflective</u>;
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>filter</u>;
</big></dt>
<dd>Property to set the type of filtering used for the textures of this layer.
<br><br>
<b>See Also:</b><br>
the TEXTURE_FILTER_* constants in yage.system.constant
<br><br>

</dd>
<dt><big>char[] <u>name</u>;
</big></dt>
<dd>Optional, the <u>name</u> of the sampler variable that uses this texture in the shader program.
<br><br>

</dd>
<dt><big>Vec!(float,2) <u>position</u>;
</big></dt>
<dd><br><br>
</dd>
<dt><big>float <u>rotation</u>;
</big></dt>
<dd><br><br>
</dd>
<dt><big>Vec!(float,2) <u>scale</u>;
</big></dt>
<dd><br><br>
</dd>
<dt><big>GPUTexture <u>texture</u>;
</big></dt>
<dd>A pointer to the actual Texture used.
<br><br>

</dd>
<dt><big>static Texture  <u>opCall</u>(GPUTexture <i>texture</i>, bool <i>clamp</i> = false, int <i>filter</i> = 300, Vec!(float,2) <i>position</i> = zero, float <i>rotation</i> = cast(float)0, Vec!(float,2) <i>scale</i> = one);
</big></dt>
<dd>Create a new TextureInstance with the parameters specified.
<br><br>

</dd>
<dt><big>void <u>bind</u>();
</big></dt>
<dd>Bind the Texture as the current OpenGL texture and apply its properties to the OpenGL state machine.
<br><br>

</dd>
<dt><big>void <u>unbind</u>();
</big></dt>
<dd>Undo state changes caused by binding this TextureInstance.
<br><br>

</dd>
<dt><big>char[] <u>toString</u>();
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big>class <u>GPUTexture</u>;
</big></dt>
<dd>A <u>GPUTexture</u> represents image data in video memory.
<br><br>
Also, there's no need to be concerned about making
 texture dimensions a power of two, as they're automatically resized up to
 the next highest supported size if the non_power_of_two OpenGL extension
 isn't supported in hardware. 
<br><br>

<dl><dt><big>this();
</big></dt>
<dd><br><br>
</dd>
<dt><big>this(char[] <i>filename</i>, bool <i>compress</i> = true, bool <i>mipmap</i> = true);
<br>this(Image <i>image</i>, bool <i>compress</i> = true, bool <i>mipmap</i> = true);
</big></dt>
<dd>Create a Texture from an image.
 This is equivalent to calling the default constructor followed by upload().
<br><br>

</dd>
<dt><big>bool <u>getCompressed</u>();
</big></dt>
<dd>Is texture compression used in video memory?
<br><br>

</dd>
<dt><big>bool <u>getMipmapped</u>();
</big></dt>
<dd>Are mipmaps used?
<br><br>

</dd>
<dt><big>uint <u>getFormat</u>();
</big></dt>
<dd>Get the format of the Texture.
<br><br>
<b>See Also:</b><br>
yage.system.constant 
<br><br>

</dd>
<dt><big>uint <u>getIndex</u>();
</big></dt>
<dd>What is the OpenGL index of this texture?
<br><br>

</dd>
<dt><big>uint <u>getHeight</u>();
</big></dt>
<dd>Return the height of the Texture in pixels.
<br><br>

</dd>
<dt><big>uint <u>getWidth</u>();
</big></dt>
<dd>Return the width of the Texture in pixels.
<br><br>

</dd>
<dt><big>char[] <u>getSource</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big>void <u>upload</u>(Image <i>image</i>, bool <i>compress</i> = true, bool <i>mipmap</i> = true);
</big></dt>
<dd>Set the Texture from an Image.
 The <i>image</i> is uploaded into video memory and resized to a power of two if necessary.
<br><br>
<b>Params:</b><br>
<table><tr><td>Image <i>image</i></td>
<td>The <i>image</i> to use for the Texture.</td></tr>
<tr><td>bool <i>compress</i></td>
<td>Compress the <i>image</i> in video memory.  This causes a slight loss of quality
 in exchange for four times less memory used.</td></tr>
<tr><td>bool <i>mipmap</i></td>
<td>Generate mipmaps.</td></tr>
</table><br>

</dd>
<dt><big>void <u>loadFrameBuffer</u>(uint <i>width</i>, uint <i>height</i>);
</big></dt>
<dd>Copy the the contents of the framebuffer into this Texture.
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>CameraTexture</u>: yage.resource.texture.GPUTexture;
</big></dt>
<dd>A Texture that is used as a rendering target by a Camera.
 Since not all video hardware supports non-power of two sized Textures,
 Textures are oversized to the next power of two when necessary.
 It is then necessary to store the size the texture wishes it was. 
<br><br>

<dl><dt><big>this();
</big></dt>
<dd><br><br>
</dd>
<dt><big>void <u>loadFrameBuffer</u>(uint <i>_width</i>, uint <i>_height</i>);
</big></dt>
<dd><u>loadFrameBuffer</u> is overridden to set requested_width and requested_height.
<br><br>

</dd>
</dl>
</dd>
</dl>

	<hr><small>Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. (c) 2005-2007 Eric Poggel
</small>
	</body></html>
