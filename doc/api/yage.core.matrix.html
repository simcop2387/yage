<html><head>
	<META http-equiv="content-type" content="text/html; charset=utf-8">
	<title>yage.core.matrix</title>
	</head><body>
	<h1>yage.core.matrix</h1>
	<!-- Generated by Ddoc from yage\core\matrix.d -->
<b>Authors:</b><br>
Eric Poggel
<br><br>
<b>License:</b><br>
<a href="lgpl.txt">LGPL</a>
 
<br><br>

<dl><dt><big>struct <u>Matrix</u>;
</big></dt>
<dd>A 4x4 matrix class for 3D transformations.
 Column major order is used, just like OpenGL.  This is defined as a struct instead of a
 class so it can be created and destroyed without any dynamic memory allocation.
 The Euler operations may be unreliable and should be used cautiously.
<br><br>
<b>See Also:</b><br>
<a href="http://en.wikipedia.org/wiki/Transformation_matrix">Wikipedia: Transformation <u>Matrix</u></a><br>
 <a href="http://www.gamedev.net/reference/articles/article1691.asp">The <u>Matrix</u> and Quaternion Faq</a>
<br><br>

<dl><dt><big>float[16] <u>v</u>;
</big></dt>
<dd>The 16 values of the Matrix.
<br><br>

</dd>
<dt><big>float <u>v00</u>;
</big></dt>
<dd>The 16 values of the Matrix.
<br><br>

</dd>
<dt><big>float <u>v01</u>;
</big></dt>
<dd>The 16 values of the Matrix.
<br><br>

</dd>
<dt><big>float <u>v02</u>;
</big></dt>
<dd>The 16 values of the Matrix.
<br><br>

</dd>
<dt><big>float <u>v03</u>;
</big></dt>
<dd>The 16 values of the Matrix.
<br><br>

</dd>
<dt><big>float <u>v10</u>;
</big></dt>
<dd>The 16 values of the Matrix.
<br><br>

</dd>
<dt><big>float <u>v11</u>;
</big></dt>
<dd>The 16 values of the Matrix.
<br><br>

</dd>
<dt><big>float <u>v12</u>;
</big></dt>
<dd>The 16 values of the Matrix.
<br><br>

</dd>
<dt><big>float <u>v13</u>;
</big></dt>
<dd>The 16 values of the Matrix.
<br><br>

</dd>
<dt><big>float <u>v20</u>;
</big></dt>
<dd>The 16 values of the Matrix.
<br><br>

</dd>
<dt><big>float <u>v21</u>;
</big></dt>
<dd>The 16 values of the Matrix.
<br><br>

</dd>
<dt><big>float <u>v22</u>;
</big></dt>
<dd>The 16 values of the Matrix.
<br><br>

</dd>
<dt><big>float <u>v23</u>;
</big></dt>
<dd>The 16 values of the Matrix.
<br><br>

</dd>
<dt><big>float <u>v30</u>;
</big></dt>
<dd>The 16 values of the Matrix.
<br><br>

</dd>
<dt><big>float <u>v31</u>;
</big></dt>
<dd>The 16 values of the Matrix.
<br><br>

</dd>
<dt><big>float <u>v32</u>;
</big></dt>
<dd>The 16 values of the Matrix.
<br><br>

</dd>
<dt><big>float <u>v33</u>;
</big></dt>
<dd>The 16 values of the Matrix.
<br><br>

</dd>
<dt><big>static Matrix  <u>opCall</u>();
</big></dt>
<dd>Create an identity Matrix.
<br><br>

</dd>
<dt><big>static Matrix  <u>opCall</u>(float[] <i>values</i>);
</big></dt>
<dd>Create a Matrix from a float[16].
<br><br>

</dd>
<dt><big>static Matrix  <u>opCall</u>(Quatrn <i>rotation</i>);
</big></dt>
<dd>Create a Matrix from the <i>rotation</i> values of a Quaternion.
<br><br>

</dd>
<dt><big>bool <u>almostEqual</u>(Matrix <i>s</i>, float <i>fudge</i> = 0.0001F);
</big></dt>
<dd>Is this Matrix equal to Matrix <i>s</i>, discarding relative error <i>fudge</i>.
<br><br>

</dd>
<dt><big>float <u>determinant</u>();
</big></dt>
<dd>Return the <u>determinant</u> of the Matrix.
<br><br>

</dd>
<dt><big>Matrix  <u>inverse</u>();
</big></dt>
<dd>Return a copy of this Matrix that has been inverted.
 Throws an exception if this Matrix has no inverse.  This occurs when the determinant is zero. 
<br><br>

</dd>
<dt><big>bool <u>isIdentity</u>();
</big></dt>
<dd>Is this an identity Matrix?
<br><br>

</dd>
<dt><big>Matrix  <u>move</u>(Vec3f <i>vec</i>);
</big></dt>
<dd>Return a copy of this Matrix with its position values incremented by <i>vec</i>.
<br><br>

</dd>
<dt><big>Matrix  <u>moveRelative</u>(Vec3f <i>direction</i>);
</big></dt>
<dd>Return a copy of this Matrix with its position values incremented relative to its rotation.
  Consider it to be moved in the <i>direction</i> that it's currently rotated. 
<br><br>

</dd>
<dt><big>Matrix  <u>negate</u>();
</big></dt>
<dd>Return a copy of this Matrix with all values negated.
<br><br>

</dd>
<dt><big>float <u>opIndex</u>(ubyte <i>i</i>);
</big></dt>
<dd>Get element <i>i</i> from the Matrix
<br><br>

</dd>
<dt><big>float <u>opIndexAssign</u>(float <i>value</i>, ubyte <i>i</i>);
</big></dt>
<dd>Assign a <i>value</i> to element <i>i</i>.
<br><br>

</dd>
<dt><big>Vec3f  <u>opMul</u>(Vec3f <i>vec</i>);
</big></dt>
<dd>Multiply this matrix by the 3-component Vec3f; assumes the 4th Vec3f component is 1.
 This is the equivalent of transforming the Vector by this Matrix. 
<br><br>

</dd>
<dt><big>Matrix  <u>opMul</u>(Matrix <i>b</i>);
</big></dt>
<dd>Multiply two matrices and return a third Matrix result.
<br><br>

</dd>
<dt><big>Matrix  <u>opMulAssign</u>(Matrix <i>b</i>);
</big></dt>
<dd>Multiply this Matrix by another matrix and store the result in this Matrix.
<br><br>

</dd>
<dt><big>Matrix  <u>postMultiply</u>(Matrix <i>b</i>);
</big></dt>
<dd>Perform Matrix multiplication in reverse (since Matrix multiplication is not cummulative.)
<br><br>

</dd>
<dt><big>void* <u>ptr</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big>Matrix  <u>rotate</u>(Vec3f <i>axis</i>);
</big></dt>
<dd>Return a copy of this Matrix rotated by an <i>axis</i> Vec3f.
<br><br>

</dd>
<dt><big>Matrix  <u>rotate</u>(Quatrn <i>rotation</i>);
</big></dt>
<dd>Return a copy of this Matrix rotated by a Quatrn, relative to it's current <i>rotation</i> axis.
<br><br>

</dd>
<dt><big>Matrix  <u>rotate</u>(Matrix <i>b</i>);
</big></dt>
<dd>Return a copy of this Matrix rotated by the rotation values of another Matrix.
 This is equivalent to a post-multiplication of only the rotation values.
<br><br>

</dd>
<dt><big>Matrix  <u>rotateAbsolute</u>(Vec3f <i>axis</i>);
</big></dt>
<dd>Return a copy of this Matrix with its rotation values incremented by an
 <i>axis</i> Vec3f, relative to the absolute worldspace <i>axis</i>.
 This function hasn't been verified to be correct in all circumstances. 
<br><br>

</dd>
<dt><big>Matrix  <u>rotateAbsolute</u>(Quatrn <i>rotation</i>);
</big></dt>
<dd>Return a copy of this Matrix with its <i>rotation</i> values incremented by a
 Quatrn, relative to the absolute worldspace axis.
 This function hasn't been verified to be correct in all circumstances. 
<br><br>

</dd>
<dt><big>Matrix  <u>rotateAbsolute</u>(Matrix <i>m</i>);
</big></dt>
<dd>Return a copy of this Matrix with its rotation values incremented by the
 rotation values of another Matrix, relative to the absolute worldspace axis.
 This function hasn't been verified to be correct in all circumstances. 
<br><br>

</dd>
<dt><big>Matrix  <u>rotateEuler</u>(Vec3f <i>euler</i>);
</big></dt>
<dd>Return a copy of this Matrix with its rotation values incremented by a Vec3f of Euler rotation angles,
 relative to it's current rotation axis.  First by x, then y, then z.
 This function hasn't been verified to be correct in all circumstances. 
<br><br>

</dd>
<dt><big>Matrix  <u>rotateEulerAbsolute</u>(Vec3f <i>euler</i>);
</big></dt>
<dd>The same as above, but rotated around the absolute worldspace axis.
 This function hasn't been verified to be correct in all circumstances. 
<br><br>

</dd>
<dt><big>void <u>set</u>(float[16] <i>values</i>);
</big></dt>
<dd>Set to an array of 16 <i>values</i>.
<br><br>

</dd>
<dt><big>void <u>set</u>(Vec3f <i>axis</i>);
</big></dt>
<dd>Set the rotation values of this Matrix from an <i>axis</i> vector.
<br><br>

</dd>
<dt><big>void <u>set</u>(Quatrn <i>rot</i>);
</big></dt>
<dd>Set the rotation values of the Matrix from a Quatrn.
<br><br>

</dd>
<dt><big>void <u>setEuler</u>(Vec3f <i>euler</i>);
</big></dt>
<dd>Set the rotation values of the matrix from a vector containing <i>euler</i> angles.
<br><br>

</dd>
<dt><big>void <u>setRotation</u>(Matrix <i>rot</i>);
</big></dt>
<dd>Set the rotation values of this Matrix from another Matrix
<br><br>

</dd>
<dt><big>Vec3f  <u>toAxis</u>();
</big></dt>
<dd>Return an axis vector of the rotation values of this Matrix.
 Note that the non-rotation values of the Matrix are lost. 
<br><br>

</dd>
<dt><big>Quatrn  <u>toQuatrn</u>();
</big></dt>
<dd>Return the rotation values of this Matrix as a Quatern.
 Note that the non-rotation values of the Matrix are lost. 
<br><br>

</dd>
<dt><big>Vec3f  <u>toEuler</u>();
</big></dt>
<dd>Convert the rotation part of the Matrix to Euler angles.
  This may be inaccurate and perhaps suffers from other faults. 
<br><br>

</dd>
<dt><big>Matrix  <u>transpose</u>();
</big></dt>
<dd>Return the <u>transpose</u> of the Matrix.  This is equivalent to
  converting a column-major Matrix to a row-major Matrix. 
<br><br>

</dd>
<dt><big>char[] <u>toString</u>();
</big></dt>
<dd>Create a string representation of this Matrix for human reading.
<br><br>

</dd>
</dl>
</dd>
</dl>

	<hr><small>Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. (c) 2005-2007 Eric Poggel
</small>
	</body></html>
