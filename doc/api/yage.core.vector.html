<html><head>
	<META http-equiv="content-type" content="text/html; charset=utf-8">
	<title>yage.core.vector</title>
	</head><body>
	<h1>yage.core.vector</h1>
	<!-- Generated by Ddoc from yage\core\vector.d -->
<b>Authors:</b><br>
Eric Poggel
<br><br>
<b>License:</b><br>
<a href="lgpl.txt">LGPL</a>
 
<br><br>

<dl><dt><big>struct <u>Vec</u>(T,int K);
</big></dt>
<dd>This is a template to create a vector of any type with any number of elements.
 Use <u>Vec</u>.v[0..n] to access the vector's elements directly, or a-d to access
 elements of vector's of size less than or equal to four.
<br><br>
<b>Example:</b><br>
<pre class="d_code"> <u>Vec</u>!(<font color=blue>real</font>, 4) a; <font color=green>// a is a four-component real vector.
</font></pre>
<br><br>

<dl><dt><big>VTK <u>opCall</u>();
</big></dt>
<dd>Create a zero vector
<br><br>

</dd>
<dt><big>VTK <u>opCall</u>(T <i>s</i>);
</big></dt>
<dd>Create a vector with all values as <i>s</i>.
<br><br>

</dd>
<dt><big>VTK <u>opCall</u>(T[K] <i>s</i>...);
</big></dt>
<dd>Create a new vector with the values s0, s1, s2, ...
<br><br>

</dd>
<dt><big>VTK <u>opCall</u>(T[] <i>s</i>);
</big></dt>
<dd>Create a new vector with the values of <i>s</i>; <i>s</i> must be at least of length K.
<br><br>

</dd>
<dt><big>VTK <u>add</u>(VTK <i>s</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>float <u>angle</u>(VTK <i>s</i>);
</big></dt>
<dd>The angle between this vector and <i>s</i>, in radians.
<br><br>

</dd>
<dt><big>VTK <u>clamp</u>(T <i>min</i>, T <i>max</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>float <u>dot</u>(VTK <i>s</i>);
</big></dt>
<dd>Return the dot product of this vector and <i>s</i>.
<br><br>

</dd>
<dt><big>float <u>length</u>();
</big></dt>
<dd>Return the length of the vector (the magnitude).
<br><br>

</dd>
<dt><big>float <u>length2</u>();
</big></dt>
<dd>Return the length of the vector squared.  This is faster than length().
<br><br>

</dd>
<dt><big>float <u>opIndex</u>(ubyte <i>i</i>);
</big></dt>
<dd>Get the element at <i>i</i>
<br><br>

</dd>
<dt><big>float <u>opIndexAssign</u>(T <i>value</i>, ubyte <i>i</i>);
</big></dt>
<dd>Assign <i>value</i> to the element at <i>i</i>
<br><br>

</dd>
<dt><big>VTK <u>projection</u>(VTK <i>s</i>);
</big></dt>
<dd>Create a new vector with the values of <i>s</i>; <i>s</i> must be at least of length 3.
<br><br>

</dd>
<dt><big>VTK <u>scale</u>(float <i>s</i>);
<br>VTK <u>scale</u>(VTK <i>s</i>);
</big></dt>
<dd>Scale (multiply) this vector.
<br><br>

</dd>
<dt><big>void <u>set</u>(T <i>s</i>);
<br>void <u>set</u>(VTK <i>s</i>);
<br>void <u>set</u>(T[K] <i>s</i>...);
</big></dt>
<dd>Set the values of the Vector.
<br><br>

</dd>
<dt><big>char[] <u>toString</u>();
</big></dt>
<dd>Return a string representation of this vector for human reading.
<br><br>

</dd>
</dl>
</dd>
<dt><big>alias <u>Vec2i</u>;
</big></dt>
<dd>A two-component int Vec
<br><br>

</dd>
<dt><big>alias <u>Vec3i</u>;
</big></dt>
<dd>A three-component int Vec
<br><br>

</dd>
<dt><big>alias <u>Vec4i</u>;
</big></dt>
<dd>A four-component int Vec
<br><br>

</dd>
<dt><big>alias <u>Vec2f</u>;
</big></dt>
<dd>A two-component float Vec
<br><br>

</dd>
<dt><big>alias <u>Vec4f</u>;
</big></dt>
<dd>A four-component float Vec
<br><br>

</dd>
<dt><big>struct <u>Vec3f</u>;
</big></dt>
<dd>A 3D vector class.  This is defined as a struct instead of a
 class so it can be created and destroyed without dynamic memory allocation.
 This is a higher-performance version of Vec (although it hasn't been profiled).
 This may be merged with Vec in the future. 
<br><br>

<dl><dt><big>static Vec3f  <u>opCall</u>();
</big></dt>
<dd>Create a zero vector
<br><br>

</dd>
<dt><big>static Vec3f  <u>opCall</u>(float <i>s</i>);
</big></dt>
<dd>Create a Vec3f with all values as <i>s</i>.
<br><br>

</dd>
<dt><big>static Vec3f  <u>opCall</u>(float <i>x</i>, float <i>y</i>, float <i>z</i>);
</big></dt>
<dd>Create a new Vec3f with the values <i>x</i>, <i>y</i>, and <i>z</i>
<br><br>

</dd>
<dt><big>static Vec3f  <u>opCall</u>(float[] <i>s</i>);
</big></dt>
<dd>Return a vector with the values of <i>s</i>; <i>s</i> must be at least of length 3.
<br><br>

</dd>
<dt><big>Vec3f  <u>abs</u>();
</big></dt>
<dd>Return a vector containing the absolute value of each component
<br><br>

</dd>
<dt><big>Vec3f  <u>add</u>(Vec3f <i>s</i>);
</big></dt>
<dd>Add another vector into this vector
<br><br>

</dd>
<dt><big>bool <u>almostEqual</u>(Vec3f <i>s</i>, float <i>fudge</i> = 0.0001F);
</big></dt>
<dd>Is this vector equal to vector <i>s</i>, discarding relative error <i>fudge</i>.
<br><br>

</dd>
<dt><big>float <u>average</u>();
</big></dt>
<dd>Return the <u>average</u> of the x, y, and z components.
<br><br>

</dd>
<dt><big>Vec3f  <u>clamp</u>(float <i>l</i>, float <i>u</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>Vec3f  <u>cross</u>(Vec3f <i>s</i>);
</big></dt>
<dd>Return the <u>cross</u> product of this vector with another vector.
<br><br>

</dd>
<dt><big>float <u>dot</u>(Vec3f <i>s</i>);
</big></dt>
<dd>Return the <u>dot</u> product of this vector and another.
<br><br>

</dd>
<dt><big>float <u>distance</u>(Vec3f <i>s</i>);
</big></dt>
<dd>Return the <u>distance</u> from this vector to another, interpreting each as 3D coordinates.
<br><br>

</dd>
<dt><big>float <u>distance2</u>(Vec3f <i>s</i>);
</big></dt>
<dd>Return the square of the distance from this Vec3f to another, interpreting each as 3D coordinates.
<br><br>

</dd>
<dt><big>Vec3f  <u>inverse</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big>float <u>length</u>();
</big></dt>
<dd>Return the <u>length</u> of the vector (the magnitude).
<br><br>

</dd>
<dt><big>float <u>length2</u>();
</big></dt>
<dd>Return the length of the vector squared.  This is faster than length().
<br><br>

</dd>
<dt><big>Vec3f  <u>length</u>(float <i>l</i>);
</big></dt>
<dd>Return a copy of this vector scaled to <u>length</u> <i>l</i>.
<br><br>

</dd>
<dt><big>float <u>max</u>();
</big></dt>
<dd>Return the maximum value of the vector components
<br><br>

</dd>
<dt><big>Vec3f  <u>negate</u>();
</big></dt>
<dd>Return a vector with every value of this Vec3f negated.
<br><br>

</dd>
<dt><big>Vec3f  <u>normalize</u>();
</big></dt>
<dd>Return a normalized copy of this vector.
<br><br>

</dd>
<dt><big>Vec3f  <u>opAdd</u>(Vec3f <i>s</i>);
</big></dt>
<dd>Return the sum of this vector and another.
<br><br>

</dd>
<dt><big>Vec3f  <u>opAddAssign</u>(Vec3f <i>s</i>);
</big></dt>
<dd>Add the values of another Vec3f into this one.
<br><br>

</dd>
<dt><big>Vec3f  <u>opDiv</u>(float <i>s</i>);
</big></dt>
<dd>Return a copy of this vector with every value divided by <i>s</i>.
<br><br>

</dd>
<dt><big>Vec3f  <u>opDivAssign</u>(float <i>s</i>);
</big></dt>
<dd>Divide every value of this vector by <i>s</i>.
<br><br>

</dd>
<dt><big>float <u>opIndex</u>(ubyte <i>i</i>);
</big></dt>
<dd>Get the element at <i>i</i>
<br><br>

</dd>
<dt><big>float <u>opIndexAssign</u>(float <i>value</i>, ubyte <i>i</i>);
</big></dt>
<dd>Assign <i>value</i> to the element at <i>i</i>
<br><br>

</dd>
<dt><big>Vec3f  <u>opMul</u>(float <i>s</i>);
</big></dt>
<dd>Return a copy of this vector with every value multiplied by <i>s</i>.
<br><br>

</dd>
<dt><big>Vec3f  <u>opMulAssign</u>(float <i>s</i>);
</big></dt>
<dd>Multiply every value of this vector by <i>s</i>.
<br><br>

</dd>
<dt><big>Vec3f  <u>opNeg</u>();
</big></dt>
<dd>Return a vector with every value of this vector negated.
<br><br>

</dd>
<dt><big>Vec3f  <u>opSub</u>(Vec3f <i>s</i>);
</big></dt>
<dd>Return the difference between this vector and another.
<br><br>

</dd>
<dt><big>Vec3f  <u>opSubAssign</u>(Vec3f <i>s</i>);
</big></dt>
<dd>Subtract the values of another vector from this one.
<br><br>

</dd>
<dt><big>float* <u>ptr</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big>static Vec3f  <u>random</u>(float <i>r</i> = cast(float)1);
</big></dt>
<dd>Return a vector in a <u>random</u> direction between length -<i>r</i> and <i>r</i>.
<br><br>

</dd>
<dt><big>Vec3f  <u>rotate</u>(Vec3f <i>axis</i>);
</big></dt>
<dd>Return a copy of this vector rotated by <i>axis</i>, where both are interpreted
 as <i>axis</i>-angle vectors.
<br><br>

</dd>
<dt><big>Vec3f  <u>rotate</u>(Quatrn <i>q</i>);
</big></dt>
<dd>Return a copy of this Vec3f rotated by the Quatrn <i>q</i>.
 Note that this is curently slower than <u>rotate</u>(Matrix m).
<br><br>

</dd>
<dt><big>Vec3f  <u>rotate</u>(Matrix <i>m</i>);
</big></dt>
<dd>Return a copy of this vector rotated by the rotation values of Matrix <i>m</i>.
<br><br>

</dd>
<dt><big>Vec3f  <u>scale</u>(float <i>s</i>);
</big></dt>
<dd>Return a copy of this vector with each component scaled by <i>s</i>.
<br><br>

</dd>
<dt><big>Vec3f  <u>scale</u>(Vec3f <i>v</i>);
</big></dt>
<dd>Return a copy of this vector scaled by the values of another vector.
<br><br>

</dd>
<dt><big>void <u>set</u>(float <i>s</i>);
</big></dt>
<dd>Assign <i>s</i> to x, y, and z.
<br><br>

</dd>
<dt><big>void <u>set</u>(float <i>a</i>, float <i>b</i>, float <i>c</i>);
</big></dt>
<dd>Assign <i>a</i>, <i>b</i>, and <i>c</i> to x, y, and z.
<br><br>

</dd>
<dt><big>void <u>set</u>(float[] <i>s</i>);
</big></dt>
<dd>Set to an array of three floats.
<br><br>

</dd>
<dt><big>void <u>set</u>(Matrix <i>m</i>);
</big></dt>
<dd>Set this vector to the translation (position) part of a 4x4 Matrix
<br><br>

</dd>
<dt><big>void <u>setAxis</u>(Matrix <i>m</i>);
</big></dt>
<dd>Set to a rotation axis from the rotation values of Matrix <i>m</i>.
<br><br>

</dd>
<dt><big>void <u>setAxis</u>(Quatrn <i>q</i>);
</big></dt>
<dd>Set to a rotation axis from the rotation values of Quatrn <i>q</i>.
<br><br>

</dd>
<dt><big>Vec3f  <u>subtract</u>(Vec3f <i>s</i>);
</big></dt>
<dd>Return the difference between this vector and another.
<br><br>

</dd>
<dt><big>Quatrn  <u>toQuatrn</u>();
</big></dt>
<dd>Interpret the values of this vector as a rotation axis and convert to
 a Quatrn.
<br><br>

</dd>
<dt><big>Matrix  <u>toMatrix</u>();
</big></dt>
<dd>Interpret the values of this vector as a rotation axis and convert to
 a rotation Matrix.
<br><br>

</dd>
<dt><big>char[] <u>toString</u>();
</big></dt>
<dd>Return a string representation of this vector for human reading.
<br><br>

</dd>
</dl>
</dd>
</dl>

	<hr><small>Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. (c) 2005-2007 Eric Poggel
</small>
	</body></html>
