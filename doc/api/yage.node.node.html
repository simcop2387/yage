<html><head>
	<META http-equiv="content-type" content="text/html; charset=utf-8">
	<title>yage.node.node</title>
	</head><body>
	<h1>yage.node.node</h1>
	<!-- Generated by Ddoc from yage\node\node.d -->
<b>Authors:</b><br>
Eric Poggel
<br><br>
<b>License:</b><br>
<a href="lgpl.txt">LGPL</a>
 
<br><br>

<dl><dt><big>class <u>Node</u>: yage.node.base.BaseNode;
</big></dt>
<dd>A <u>Node</u> is an instance of some tpe of object in a Scene.
 Every node has an array of child nodes as well as a parent node, with
 the obvious exception of a Scene whose parent is <b>null</b>.  When one node
 is moved or rotated, all of its child nodes move and rotate as well.
 Likewise, setting the position or rotation of a node does so relative
 to its parent.  Rendering is done recursively from the Scene down
 through every child node.  Likewise, updating of position and rotation
 occurs recusively from Scene's update() method.  All <u>Node</u> methods that deal
 with position or velocity are separated into yage.node.moveable to keep things
 tidier.
<br><br>
<b>See Also:</b><br>
yage.node.MoveableNode
 yage.node.BaseNode

<br><br>
<b>Example:</b><br>
<pre class="d_code"> Scene s = <font color=blue>new</font> Scene();
 <u>Node</u> a = <font color=blue>new</font> <u>Node</u>(s);      <font color=green>// a is a child of s, it exists in Scene s.
</font> a.setPosition(3, 5, 0);    <font color=green>// Position is set relative to 0, 0, 0 of the entire scene.
</font> a.setRotation(0, 3.14, 0); <font color=green>// a is rotated PI radians (180 degrees) around the Y axis.
</font>
 <u>Node</u> b = <font color=blue>new</font> <u>Node</u>(a);      <font color=green>// b is a child of a, therefore,
</font> b.setPosition(5, 0, 0);    <font color=green>// it's positoin and rotation are relative to a's.
</font> b.getAbsolutePosition();   <font color=green>// Returns Vec3f(-2, 5, 0), b's position relative to the origin.
</font>
 b.setParent(s);            <font color=green>// B is now a child of s.
</font> b.getAbsolutePosition();   <font color=green>// Returns Vec3f(5, 0, 0), since it's position is relative
</font>                            <font color=green>//to 0, 0, 0, instead of a.
</font></pre>
 
<br><br>

<dl><dt><big>this(BaseNode <i>parent</i>);
</big></dt>
<dd>Construct this Node as a child of <i>parent</i>.
<br><br>

</dd>
<dt><big>this(BaseNode <i>parent</i>, Node <i>original</i>);
</big></dt>
<dd>Construct this Node as a copy of another Node and recursively copy all children.
<br><br>
<b>Params:</b><br>
<table><tr><td>BaseNode <i>parent</i></td>
<td>This Node will be a child of <i>parent</i>.</td></tr>
<tr><td>Node <i>original</i></td>
<td>This Node will be an exact copy of <i>original</i>.</td></tr>
</table><br>

</dd>
<dt><big>Vec!(float,4)  <u>getColor</u>();
</big></dt>
<dd>Get the color of the Node.
<br><br>

</dd>
<dt><big>float <u>getLifetime</u>();
</big></dt>
<dd>Get the time before the Node will be removed.
<br><br>

</dd>
<dt><big>LightNode[] <u>getLights</u>();
</big></dt>
<dd>Get an array of lights that were enabled in the last call to enableLights().
<br><br>

</dd>
<dt><big>bool <u>getOnscreen</u>();
</big></dt>
<dd>Get whether this node is inside the view frustum and large enough to be drawn by
 the last camera that rendered it. 
<br><br>

</dd>
<dt><big>float <u>getRadius</u>();
</big></dt>
<dd>Get the radius of this Node's culling sphere.
<br><br>

</dd>
<dt><big>Vec3f  <u>getScale</u>();
</big></dt>
<dd>Get the scale of the Node.
<br><br>

</dd>
<dt><big>bool <u>getVisible</u>();
</big></dt>
<dd>Is rendering enabled for this node?
<br><br>

</dd>
<dt><big>void <u>remove</u>();
</big></dt>
<dd>Remove this Node.  This function should be used instead of delete.
<br><br>

</dd>
<dt><big>void <u>setColor</u>(float <i>r</i>, float <i>g</i>, float <i>b</i>, float <i>a</i> = cast(float)1);
<br>void <u>setColor</u>(Vec!(float,4) <i>color</i>);
</big></dt>
<dd>Set the color of the Node, multiplied with the material properties.
 This is equivalent to glColor4f(). If the materials of any meshes have
 blending enabled, their alpha value can be set via the fourth parameter.
 Default color is white (all 1's).
<br><br>

</dd>
<dt><big>void <u>setLifetime</u>(float <i>seconds</i>);
</big></dt>
<dd>The Node will be removed (along with all of its children) after a given time.
<br><br>
<b>Params:</b><br>
<table><tr><td>float <i>seconds</i></td>
<td>The number of <i>seconds</i> before the Node will be removed.
 Set to float.infinity to make the Node last forever (the default behavior).</td></tr>
</table><br>

</dd>
<dt><big>Node <u>setParent</u>(BaseNode <i>_parent</i>);
</big></dt>
<dd>Set the parent of this Node (what it's attached to) and remove
 it from its previous parent.
<br><br>
<b>Returns:</b><br>
A self reference.
<br><br>

</dd>
<dt><big>void <u>setScale</u>(float <i>x</i>, float <i>y</i>, float <i>z</i>);
<br>void <u>setScale</u>(Vec3f <i>scale</i>);
<br>void <u>setScale</u>(float <i>scale</i>);
</big></dt>
<dd>Set the scale of this Node in the <i>x</i>, <i>y</i>, and <i>z</i> directions.
 The default is (1, 1, 1).  Unlike position and rotation, scale is not inherited. 
<br><br>

</dd>
<dt><big>void <u>setVisible</u>(bool <i>visible</i>);
</big></dt>
<dd>Set whether this Node will be renered.  This has nothing to do with frustum culling.
  Setting a Node as invisible will not make its children invisible also. 
<br><br>

</dd>
</dl>
</dd>
</dl>

	<hr><small>Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. (c) 2005-2007 Eric Poggel
</small>
	</body></html>
