<html><head>
	<META http-equiv="content-type" content="text/html; charset=utf-8">
	<title>yage.resource.layer</title>
	</head><body>
	<h1>yage.resource.layer</h1>
	<!-- Generated by Ddoc from yage\resource\layer.d -->
<b>Authors:</b><br>
Eric Poggel
<br><br>
<b>License:</b><br>
<a href="lgpl.txt">LGPL</a>
 
<br><br>

<dl><dt><big>class <u>Layer</u>;
</big></dt>
<dd>Each material is divided into one or more layers.
 Layers represent a single rendering pass.  They can optionally have shaders
 that compile into a single program, multiple textures, and various other
 rendering attributes.
 If no shaders are specified, the material uses the default fixed-function
 OpenGL rendering mode. If Textures are supplied, the first will be used as
 the regular diffuse color map, the second as a normal map, and the third as
 an environment map.  (This part still needs to be completed).
<br><br>
When an xml Material file is loaded, this class is used to represent each <u>Layer</u>
 defined in the file. 
<br><br>

<dl><dt><big>Vec!(float,4) <u>ambient</u>;
</big></dt>
<dd>Property for the RGBA <u>ambient</u> layer color, default is Vec4f(0).
<br><br>

</dd>
<dt><big>Vec!(float,4) <u>diffuse</u>;
</big></dt>
<dd>Property for the RGBA <u>diffuse</u> layer color, default is Vec4f(1).
<br><br>

</dd>
<dt><big>Vec!(float,4) <u>specular</u>;
</big></dt>
<dd>Property for the RGBA <u>specular</u> layer color, default is Vec4f(0).
<br><br>

</dd>
<dt><big>Vec!(float,4) <u>emissive</u>;
</big></dt>
<dd>Property for the RGBA <u>emissive</u> layer color, default is Vec4f(0).
<br><br>

</dd>
<dt><big>float <u>specularity</u>;
</big></dt>
<dd>Shininess exponential value, default is zero (no shininess).
<br><br>

</dd>
<dt><big>int <u>blend</u>;
</big></dt>
<dd>Property to set the blending for this Layer.
<br><br>
<b>See Also:</b><br>
the LAYER_BLEND_* constants in yage.system.constant;
<br><br>

</dd>
<dt><big>int <u>cull</u>;
</big></dt>
<dd>Property to set whether the front or back faces of polygons are culled (invisible).
<br><br>
<b>See Also:</b><br>
the LAYER_CULL_* constants in yage.system.constant
<br><br>

</dd>
<dt><big>int <u>draw</u>;
</big></dt>
<dd>Property to set whether the layer is drawn as polygons, lines or points.
<br><br>
<b>See Also:</b><br>
the LAYER_DRAW_* constants in yage.system.constant
<br><br>

</dd>
<dt><big>int <u>width</u>;
</big></dt>
<dd>Property to set the <u>width</u> of lines and points when the layer is rendered as such.
<br><br>

</dd>
<dt><big>this();
</big></dt>
<dd>Set layer properties to default values.
<br><br>

</dd>
<dt><big>int <u>addShader</u>(Shader <i>shader</i>);
</big></dt>
<dd>Add a Shader to this Layer.  Call linkShaders() to recompile the program.
<br><br>
<b>Returns:</b><br>
the index of the new Shader in the Shader array. 
<br><br>

</dd>
<dt><big>int <u>addTexture</u>(GPUTexture <i>texture</i>, bool <i>clamp</i> = false, int <i>filter</i> = 300, Vec!(float,2) <i>position</i> = zero, float <i>rotation</i> = cast(float)0, Vec!(float,2) <i>scale</i> = one);
<br>int <u>addTexture</u>(Texture <i>texture</i>);
</big></dt>
<dd>Add a new <i>texture</i> to this layer and return it.
<br><br>

</dd>
<dt><big>uint <u>getShaderProgram</u>();
</big></dt>
<dd>Return the OpenGL handle to the linked shader program.
 This value will most likely be zero unless shaders have been
 loaded and linked.
<br><br>

</dd>
<dt><big>Shader[] <u>getShaders</u>();
</big></dt>
<dd>Return the array of shader obects used by this layer.
<br><br>

</dd>
<dt><big>Texture [] <u>getTextures</u>();
</big></dt>
<dd>Get an array of all the textures of this layer.
<br><br>

</dd>
<dt><big>int <u>getProgram</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big>char[] <u>getShaderProgramLog</u>();
</big></dt>
<dd>Get messages from the shader program.
<br><br>

</dd>
<dt><big>void <u>linkShaders</u>();
</big></dt>
<dd>Link all vertex and fragment shaders together into a shader program.
<br><br>

</dd>
<dt><big>void <u>setUniform</u>(char[] <i>name</i>, float[] <i>values</i>...);
<br>void <u>setUniform</u>(char[] <i>name</i>, Vec!(float,2) [] <i>values</i>...);
<br>void <u>setUniform</u>(char[] <i>name</i>, Vec3f [] <i>values</i>...);
<br>void <u>setUniform</u>(char[] <i>name</i>, Vec!(float,4) [] <i>values</i>...);
<br>void <u>setUniform</u>(char[] <i>name</i>, Matrix [] <i>values</i>...);
</big></dt>
<dd>Set a the value of a uniform variable (or array of uniform variables) in this Layer's Shader program.
<br><br>

</dd>
<dt><big>char[] <u>toString</u>();
</big></dt>
<dd>Return a string of xml for this layer.
<br><br>

</dd>
</dl>
</dd>
</dl>

	<hr><small>Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. (c) 2005-2007 Eric Poggel
</small>
	</body></html>
